(defun modular_pow (base exponent modulus)
	(let ((result 1))
		(loop 
			(when (eq exponent 0) (return result))
			(and (eq (mod exponent 2) 1) (setq result (mod (* result base) modulus)))
			(setq exponent (ash exponent -1))
			(setq base (mod (* base base) modulus))
		)
	)
)
(defun factoring_decompose (number result) ; gives number as 2^result * m
	(cond
		((eq (mod number 2) 0) (factoring_decompose (/ number 2) (+ result 1)))
		(t result)
	)
)
(defun miller_rabin_primality_test (number)
	(let* 
		(
			(s (factoring_decompose (- number 1) 0))
			(d (/ (- number 1) (expt 2 s)))
			(a (random (- number 1))) 
			(x (modular_pow a d number))
			)
			(cond 
				((or (eq x 1) (eq x (- number 1))) t)
				(t 
				(dotimes (i (- s 1))
				(setq x (mod (expt x 2) number))
				(and (eq x 1) (return ()))
				(and (eq x (- number 1)) (return t))
			)
		)
	))
)
(defun brute_check_for_primality (number); brutally check for all supposedly primes upto 30000.
	(cond
		( (eq (mod number 2) 0) nil )
		( (eq (mod number 3) 0) nil )
		( (eq (primality number (min 30000 (/ number 2)) ) nil) nil)
		( t t)
		)
	)
(defun primality (number fin)
	 (do ((i 1 (+ i 1)))
		 ( (> (- (* 6 i) 1) fin ) t )
		 (cond
			((or (eq (mod number (- (* 6 i) 1)) 0) (eq (mod number (+ (* 6 i) 1)) 0)) (return-from
			primality nil))
			(t t)
		)
	 )
)
(defun check_for_primality (number) 
	(and (brute_check_for_primality number) 
		(dotimes (n 50)
		(when (eq (miller_rabin_primality_test number) t) (return t))
		)
	)
)
(defun produce_list (a res fin)
	(cond
	((> a fin) (reverse res) )
	(t (and (setq res (cons a res)) (produce_list (+ a 1) res fin))) )
)
(defun generate_random_prime ()
	(let* 
		(
			(a (random (- (- (expt 2 512) 1) (expt 2 511)))) 
			(b a)
			(lst (mapcar #'check_for_primality (produce_list a () (+ a 355)))) 
			)
			(cond
			((eq (position t lst) nil) (generate_random_prime ))
			( t (+ b (position t lst)))
			)
		)
	)
(defun extended_euclid (a b)
	(cond
	((eq a 0) (cons b (cons (cons 0 (cons 1 ()))())))
	(t 
		(and (setq p (extended_euclid (mod b a) a)) (cons (car p) (cons (cons (- (car (cdr (car (cdr
	p)))) (* (car (car (cdr p))) (floor b a))) (cons (car (car (cdr p)))()))())))
	)
	)
)
(defun mod_inverse (a m)
	(mod (+ (car (car (cdr (extended_euclid a m)))) m) m)
)
(defun generate_keys ()
	(let* 
		(
		(p (generate_random_prime))
		(q (generate_random_prime))
		(n (* p q))
		(fn (* (- p 1) (- q 1)))
		(e (nth (random 3) '(17 257 65537))) ;; exponents - simple Fermat numbers
		(d (mod_inverse e fn))
		)
		(list e d n)
	)
)
(defun cipher (message exponent modulo)
	(modular_pow message exponent modulo)
)
(defun logp (number base)
	(cond
	((integerp (log number base)) (+ 1 (log number base)))
	(t (ceiling (log number base)))
	)
)
(defun decompose (lst result multiplier resultlist)
	(cond
	((eq lst ()) (reverse (cons (/ result (expt 10 multiplier)) resultlist)))
	(t (cond
	((>= multiplier (ceiling (logp (car lst) 10))) (and (setq result (+ (+ result (* (car
	lst) (expt 10 (- multiplier (ceiling (logp (car lst) 10)))))) (* (ceiling (logp (car lst) 10)) (expt 10 (- multiplier 5))) )
	) (decompose (cdr lst) result (- multiplier 5) resultlist)))
	(t (decompose lst 0 50 (cons (/ result (expt 10 multiplier)) resultlist)))
	)
	)
	)
)
(defun read_message ()
	(let 
	((message (read-line))) (decompose (loop for char across message collect (char-code char)) 0 50 ())
	)
)
(defun encrypt_rsa (messagelist resultlist publickey modulo)
	(cond
	((eq messagelist ()) (reverse resultlist))
	(t (encrypt_rsa (cdr messagelist) (cons (cipher (car messagelist) publickey modulo) resultlist)
	publickey modulo ))
	)
)
(defun reverse-element-after (lst index)
	(append (reverse (butlast lst (- (list-length lst) index))) (last lst (- (list-length lst) index)))
)
(defun compose (lst result lastto)
	(cond
		((eq lst ()) (reverse result))
		((eq (car lst) 0) (compose (cdr lst) (reverse-element-after result (cond 
		((eq (mod (list-length result) 10) 0) 10)
		(t (mod (list-length result) 10))
	)) 
	(cond 
		((eq (mod (list-length result) 10) 0) 10)
		(t (mod (list-length result) 10))
		)
		))
		(t 
		(compose (cons (floor (car lst) 100000) (cdr lst)) (cons (floor (mod (car lst) 100000)
		(expt 10 (- 5 (mod (car lst) 10)) )) result) lastto)
		)
	)
)
(defun start ()
	(let* (
	(message (read_message))
	(keys (generate_keys))
	(public_key (first keys))
	(private_key (second keys))
	(modulo (third keys))
	(encrypted (encrypt_rsa message () public_key modulo))
)
(format t "Public key: (~D, ~D) ~%" public_key modulo)
(format t "Private key: (~D, ~D) ~%" private_key modulo)
(format t "Encrypted message: ~S ~%" encrypted)
(format t "Decrypted message: ~%")
(format t "~{~a~}" (mapcar #'string (mapcar #'code-char (compose (encrypt_rsa encrypted ()
private_key modulo) () 10 ))))
)
)